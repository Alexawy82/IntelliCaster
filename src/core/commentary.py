import os
import time

import elevenlabs
from mutagen.mp3 import MP3
import openai

from core import common


class Commentary:
    """Manages the TextGenerator and VoiceGenerator classes.

    The Commentary class is responsible for generating text commentary based
    on events, roles, tones, and additional information. It is then responsible
    for generating audio for the commentary once it has been generated. This
    allows commentary to be generated by a single function call.
    """

    def __init__(self):
        """Initialize the Commentary class.

        Initializes the TextGenerator and VoiceGenerator classes.

        Attributes:
            text_generator (TextGenerator): The TextGenerator class.
            voice_generator (VoiceGenerator): The VoiceGenerator class.
        """
        # Create the text generator
        self.text_generator = TextGenerator()

        # Create the voice generator
        self.voice_generator = VoiceGenerator()

    def generate(
            self, 
            events,
            role,
            rec_start_time=0,
            camera=None
        ):
        """Generate commentary for the given event.

        Generates text commentary for the given event based on the provided
        instructions, then generates audio for the commentary.

        Args:
            event (str): The event that occurred.
            lap_percent (float): The percentage of the lap the event occurred
                on.
            role (str): The role of the commentator.
            tone (str): The tone of the commentary.
            other_info (str): Additional information to be included in the
                system message.
            yelling (bool): Whether or not to convert the text to yelling.
            rec_start_time (float): The time the recording started.
        """
        # Get the start time of this method
        start_time = time.time()

        # Get the timestamp
        timestamp = time.time() - rec_start_time

        # Convert the timestamp to milliseconds
        timestamp = int(timestamp * 1000)

        # Generate the commentary text
        text = self.text_generator.generate(
            events=events,
            role=role,
            camera=camera
        )

        # Add the message to the message box
        common.app.add_message(f"{role.title()}: {text}")

        # Pick the correct voice for the role
        if role == "play-by-play":
            voice = common.settings["commentary"]["pbp_voice"]
        elif role == "color":
            voice = common.settings["commentary"]["color_voice"]

        # Calculate how long it took to generate the text
        gpt_time = time.time() - start_time

        # Generate the audio
        self.voice_generator.generate(
            text=text,
            timestamp=timestamp,
            gpt_time=gpt_time,
            voice=voice
        )

class TextGenerator:
    """Handles text generation for race commentary.

    Uses OpenAI's GPT to generate text commentary based on events, roles,
    tones, and additional information. Maintains a list of previous responses
    to use as context for future commentary.
    """

    def __init__(self):
        """Initialize the TextGenerator class.
    
        Initializes the OpenAI API key and sets up an empty list to hold
        previous responses generated for commentary.

        Attributes:
            previous_responses (list): A list of previous responses generated
            for commentary.
        """

        # Create the OpenAI client
        self.client = openai.OpenAI(
            api_key=common.settings["keys"]["openai_api_key"]
        )
        
        # Set the GPT model to use
        self.model = "gpt-4-turbo-preview"

        # Create an empty list to hold previous responses
        self.previous_responses = []

    def _get_camera_focus(self, event):
        """Get the camera for the given event.
        
        Using GPT to determine which car to focus on, pick a car to focus on
        based on the event.
        
        Args:
            event (str): The event that occurred.
            
        Returns:
            int: The car number to focus on.
        """
        # Create an empty list of messages
        messages = []

        # Create the instruction message
        content = "Based on the commentary generated for this event, which car "
        content += "should the camera focus on? "
        content += "Answer with only the driver's full name from the following "
        content += "list, exactly as it appears in this list, "
        content += "and nothing else.\n\n"
        content += "The drivers are:\n"
        for driver in common.drivers:
            content += f"{driver["name"]}"
            content += "\n"
        instruction = {
            "role": "system",
            "name": "camera_focus",
            "content": content
        }
        messages.append(instruction)

        # Add the event message
        event_msg = {
            "role": "user",
            "content": event
        }
        messages.append(event_msg)

        # Call the API
        response = self.client.chat.completions.create(
            model=self.model,
            messages=messages,
            max_tokens=100
        )

        # Extract the response
        answer = response.choices[0].message.content

        # Pick the driver number which matches the answer
        for driver in common.drivers:
            if driver["name"].lower() in answer.lower():
                return driver["number"]
            
        # If no match is found, return None
        return None

    def _parse_event(self, event):
        """Parse the event dictionary to create a string.
        
        Args:
            event (dict): The event dictionary to parse.
            
        Returns:
            str: The parsed event string.
        """
        # Create the string to return
        event_str = ""
        
        # Add the event type
        event_str += f"{event['type']} - "

        # Add the description
        event_str += f"{event['description']} - "

        # Add the lap percentage
        adjusted_percent = event["lap_percent"] * 100.
        adjusted_percent = round(adjusted_percent, 3)
        event_str += f"{adjusted_percent}% of the way through the lap - "

        # Get the amount of time ago it occurred
        time_ago = time.time() - event["timestamp"]
        time_ago = round(time_ago, 3)

        # Add the time
        event_str += f"{time_ago} seconds ago"

        return event_str

    def generate(self, events, role, camera=None):
        """Generate text commentary for the given event.
        
        Generates text commentary for the given event based on the provided
        instructions. Uses the provided iRacing information to provide context
        for the commentary. Adds the generated commentary to the list of
        previous responses.
        
        Args:
            events (list): A list of events that have occurred.
            role (str): The role of the commentator.
            camera (int): The car number to focus on.
        
        Returns:
            str: The generated commentary.
        """
        # Create an empty list to hold the messages
        messages = []

        # Start building the system message
        new_msg = ""

        # Add messages based on role
        if role == "play-by-play":
            # Add the name to the system message
            new_msg += "You are an iRacing play-by-play commentator. "

            # Add play-by-play instructions
            new_msg += "You will respond with only one sentence. "
            new_msg += "Do not provide too much detail. Focus on the action. "
            new_msg += "Do not just say the word \"play-by-play\". "

        elif role == "color":
            # Add the name to the system message
            new_msg += "You are an iRacing color commentator. "

            # Add color instructions
            new_msg += "You will respond with one to two short sentences. "
            new_msg += "Stick to providing insight or context that enhances "
            new_msg += "the viewer's understanding. "
            new_msg += "Do not make up corner names or numbers. "
            new_msg += "Do not just say the word \"color\". "

        # Add common instructions
        new_msg += "Almost always refer to drivers by only their surname. "

        # Add the initial system message
        sys_init = {
            "role": "system",
            "name": "instructions",
            "content": new_msg
        }
        messages.append(sys_init)

        # Start building the context system message
        new_msg = ""

        # For each available value, add it to the message
        if common.context.get("league", {}).get("name") is not None:
            new_msg += f"The league is {common.context['league']['name']}. "
        if common.context.get("league", {}).get("short_name") is not None:
            # If the league short name is one word, add hyphens between letters
            if len(common.context["league"]["short_name"].split()) == 1:
                short_name = ""
                for letter in common.context["league"]["short_name"]:
                    short_name += f"{letter.upper()}-"

                # Remove the last hyphen
                short_name = short_name[:-1]

            new_msg += "The league can be abbreviated as "
            new_msg += f"{short_name}. "

        # If the new message is not empty, add it to the list of messages
        if new_msg != "":
            sys_context = {
                "role": "system",
                "name": "context",
                "content": new_msg
            }
            messages.append(sys_context)

        # Start building the event info system message if iRacing is connected
        if common.ir.is_initialized and common.ir.is_connected:
            new_msg = ""

            # Gather the general information
            track = common.ir["WeekendInfo"]["TrackDisplayName"]
            city = common.ir["WeekendInfo"]["TrackCity"]
            country = common.ir["WeekendInfo"]["TrackCountry"]
            air_temp = common.ir["WeekendInfo"]["TrackAirTemp"]
            track_temp = common.ir["WeekendInfo"]["TrackSurfaceTemp"]
            skies = common.ir["WeekendInfo"]["TrackSkies"]

            # Compile that information into a message
            new_msg += f"The race is at {track} in {city}, {country}. "
            new_msg += f"The air temperature is {air_temp}., and "
            new_msg += f"the track temperature is {track_temp}. "
            new_msg += f"The skies are {skies.lower()}. "

            # Add the event info system message
            sys_event = {
                "role": "system",
                "name": "event_info",
                "content": new_msg
            }
            messages.append(sys_event)

        # Add the gaps to leader message (from common.drivers)
        gap_msg = "Here are the gaps to the leader:\n"
        for driver in common.drivers:
            driver_name = common.remove_numbers(driver["name"])
            rounded_gap = round(driver["gap_to_leader"], 3)
            gap_msg += f"- {driver_name}: +{rounded_gap}"
            gap_msg += "\n"
        gap_msg += "Only use this information if it is relevant to the event. "
        gap_msg += "If gaps have been mentioned recently, do not mention them."
        gap_msg = {
            "role": "system",
            "name": "gaps_to_leader",
            "content": gap_msg
        }
        messages.append(gap_msg)

        # Add all previous responses to the list
        for msg in self.previous_responses:
            messages.append(msg)

        # Add the event messages if this is the play-by-play role
        if role == "play-by-play":
            event_msg = "The following events have recently occurred:\n"
            for event in events:
                parsed_event = self._parse_event(event)
                event_msg += f"- {parsed_event}"
                event_msg += "\n"
            event_msg += "Report on the most exciting events. "
            event_msg += "If two events are related, mention them together. "
            event_msg += "Determine if events are related by type, "
            event_msg += "lap percentage, and/or time. "
            event_msg += "DO NOT mention the exact time of the event. "
            event_msg += "Use lap distance to estimate the corner name/number. "
            event_msg += "NEVER repeat events that have already been reported. "

        # Otherwise, create an empty message
        else:
            event_msg = ""

        # If the race has a lap count, get the laps started and total
        if common.ir.is_initialized and common.ir.is_connected:
            if common.ir["SessionLapsTotal"] < 30000:
                current_lap = max(common.ir["CarIdxLap"])
                total_laps = common.ir["SessionLapsTotal"]

                # Add the lap information to the message
                event_msg += f"The race is on lap {current_lap}/{total_laps}."
            
            # Otherwise, the race is timed, so get those numbers instead
            else:
                current_time = common.race_time
                total_time = common.ir["SessionTimeTotal"]

                # Convert the times to hours, minutes, and seconds
                current_time = time.strftime(
                    "%H:%M:%S",
                    time.gmtime(current_time)
                )
                total_time = time.strftime(
                    "%H:%M:%S",
                    time.gmtime(total_time)
                )

                # Add the time information to the message
                event_msg += f"{current_time} of {total_time} has elapsed "
                event_msg += "in the race."
        
        # If the event message is not empty, add it to the list of messages
        if event_msg != "":
            event_msg = {
                    "role": "user",
                    "content": event_msg
                }
            messages.append(event_msg)

        # Call the API for the main response
        response = self.client.chat.completions.create(
            model=self.model,
            messages=messages,
            max_tokens=300
        )

        # Extract the response
        answer = response.choices[0].message.content

        # Add the response to the list of previous responses
        formatted_answer = {
            "role": "assistant",
            "name": "Play-By-Play" if role == "play-by-play" else "Color",
            "content": answer
        }
        self.previous_responses.append(formatted_answer)

        # Get the camera focus target
        next_camera = self._get_camera_focus(answer)

        # Switch the camera to the new target
        if next_camera is not None:
            camera.change_camera(next_camera, "TV1")

        # If the list is too long, remove the two oldest responses
        length = int(common.settings["commentary"]["memory_limit"]) * 2
        if len(self.previous_responses) > length:
            self.previous_responses.pop(0)
            self.previous_responses.pop(0)

        # Return the answer
        return answer
    
class VoiceGenerator:
    """Handles text-to-speech functionality for race commentary.

    Utilizes the ElevenLabs API to convert text into audio. Handles the
    generation and saving of audio files.
    """

    def __init__(self):
        """Initialize the VoiceGenerator class with the given settings.

        Sets up the API key for the ElevenLabs service, enabling text-to-speech
        capabilities for the application.
        """

        # Set the API key
        elevenlabs.set_api_key(common.settings["keys"]["elevenlabs_api_key"])

    def generate(self, text, timestamp, gpt_time, voice="Harry"):
        """Generate and save audio for the provided text.

        Calls the ElevenLabs API to create audio from the text using the
        specified voice, then saves the audio.

        Args:
            text (str): The text to convert to audio.
            timestamp (str): The timestamp of the event.
            yelling (bool): Whether or not to convert the text to yelling.
            voice (str): The voice to use for the audio.
        """
        # Get the start time of this method
        start_time = time.time()

        # Replace "P" with "P-" to avoid issues with the API
        for i in range(len(text)):
            if text[i] == "P" and text[i + 1].isdigit():
                # Replace the P with "P-"
                text = text[:i] + "P-" + text[i + 1:]

        # Generate and play audio
        audio = elevenlabs.generate(
            text=text,
            voice=voice,
            model="eleven_monolingual_v1"
        )

        # Get the iRacing videos folder
        path = os.path.join(
            common.settings["general"]["iracing_path"],
            "videos"
        )

        # Create the file name
        file_name = f"commentary_{timestamp}.mp3"

        # Save the audio to a file
        elevenlabs.save(audio, os.path.join(path, file_name))

        # Add the new audio file to intellicaster.tmp
        with open(os.path.join(path, "intellicaster.tmp"), "a") as file:
            file.write(f"{file_name}\n")

        # Get the length of the audio file
        mp3_file = MP3(os.path.join(path, file_name))
        length = mp3_file.info.length

        # Calculate how long it took to generate the audio
        gen_time = time.time() - start_time

        # Wait for the length of the audio minus the time it took to generate
        if length - gen_time - gpt_time > 0:
            time.sleep(length - gen_time - gpt_time)